
http://www.scala-lang.org/api/2.11.8/?_ga=1.68205906.2111031481.1477503377#package

C:\FAST\Learn\jdui>java -jar jd-gui-1.4.0.jar

-----------------------
val language: String = "Scala";  val is equivalent to final

Show view -> Scala Interpreter will show the REPL inside Eclipse

is there an immutable collection (no add or remove) in java 8? 

Swapping is possible

 def swap(first:Int, second:Int) {
print(first + "  " + second)
}

 swap: (first: Int, second: Int)Unit

 swap(1,2)

 1  2

 swap(first=1, second=2)

 1  2

 swap(second=2, first=1)

 1  2
 
 ----------------
 
 (0 to 5).foreach(print(_))

 012345
 -------------
 
 class Customer(val name:String, val address:String) {
 }
 This is primary constructor.
 
 
 class Customer(val name:String, val address:String) {
}
 object Customer {
 def main(args:Array[String]) {
   val eric = new Customer("Rajesh", "3, Lathom Road, London")
 }
}
-----------------

Find a decompiler and verify the class files generated by Scalac or use the javap from java
------------------

How to override auto generated get/set methods ?
Rename the field
Mark it as private
Recreate getter and setter
-----------------
Fields within classes
count++ is not supported. Use count+=1

Auxiliary constructor def this(..) should call another constructor

When methods don't depend on the class, they can be called as Functions
Functions generally belong to the Singleton objects, rather than a class. When you have to distinguish between Functions and Methods, use Functions in the Companion objects, but keep the related ones close to the Class

The apply method

Inheritance
Only primary constructor can call the super class constructor
Annonymous classes are same as Java

Interfaces are called Traits
Any unimplemented method is automatically abstract
extends is used and not implements
override keyword for the method is optional

Ordered in Scala


-----------------
IntelliJ settings
https://www.youtube.com/watch?v=CuPXreWv96c

sbt gen-idea  = this command is equivalent to mvn eclipse eclipse


hot keys
press ctrl on a line to see more
press alt= on an expression to inspect statically
press alt space for code completion



Four ways of using the existing code base in the order of 'Amount of work involved'

1. Evolve Code base - Follow the trend (Most Most common)
2. Refactor and Extend - Break into components, find reusable components, refactor(Most Common)
3. Supplemented with New Architecture - Write a new Architecture component that passively uses the existing ones (Common)
4. Complete  (Never)

Oct 29, 2016
Github and IntelliJ
Scalatest
SBT
SBT and Scala outside intellij


classes with Unimplemented methods are automatically abstract. there is no abstract keyword in Scala
java's implements is extends in Scala
Multiple implementations are 'with'. for example Class Customer extends Readable with Sortable

Abstract classes
The classes can be abstract, but there is no need to mark a method as abstract

Odersky calls traits with behaviour (default methods and variables) as “mixin traits”. 

Trait can extend classes, interfaces cannot extend classes
class Animal
trait HasWings extends Animal 


map is a transforming function - returns one value at a time (one to one transformation)
flatMap is a transforming function  - returns multiple values at a time (one to many transformation)

Scala Intellij tricks
Alt + = on an expression in Scala shows the type
Refactor -> Convert to Scala  (this will convert your scala file to a java file)

implicits
curry ()()
::
Monads - Complete
For Comprehension - Complete
Adopting Scala - Complete
ScalaTest Hello world http://blog.dataglot.com/craftmanship/effective-assertions-from-java-to-scala/  https://gist.github.com/bvenners
ScalaTest Matchers

---------------
Create a new Scala project using SBT. This creates the scala and java folders
Intellij->VCS-> Import into version control -> Share on Github (If you type in the repo name, the repo will be automatically created in the github)


http://twitter.github.io/effectivescala/
http://www.scalatest.org/user_guide/selecting_a_style
http://blog.dataglot.com/craftmanship/effective-assertions-from-java-to-scala/
https://gist.github.com/bvenners/6b52677e801683df8d0a

Functions vs OOAD
http://stackoverflow.com/questions/2078978/functional-programming-vs-object-oriented-programming
https://www.quora.com/What-does-object-oriented-programming-do-better-than-functional-programming-and-why-is-it-the-most-popular-paradigm-when-everybody-seems-to-say-functional-programming-is-superior

A customer may or may not exist in the repository
	customer = customers.fin(name) - Could be null
A customer may or may not have an address
	address = customer.address - Could be null
An Address must have a street, but may not have a post code
	street = address.postcode 
	postCode = address.postcode - Could be null

http://aperiodic.net/phil/scala/s-99/

https://skillsmatter.com/skillscasts/6021-scalatest-and-scalactic-3-0

Actors in Scala
http://viewer.books24x7.com/Toc.aspx?bookid=45721

two mocking styles: Expectations-First Style (mocks) and Record-then-Verify (stubs). 

Language - how easy it could be to express ideas with software


Scala xChange prep
the Reader monad to "inject" components and configuration, and the Free monad to decouple the specification of a program from its implementation.
"Practical eff monad for micro-services" 
Monads 
Type
implicits
Functors
Akka Streams / Reactive Streams
ScalaCheck


ScalaMock - GenerateMocks
In order to create mock objects, we need to tell ScalaMock to generate the appropriate code by using the @mock annotation. Create src/generate-mocks/scala/GenerateMocks.scala containing: 


http://viewer.books24x7.com/assetviewer.aspx?bookid=59457&chunkid=879849305&resumebookmarkid=5eda7b24-aab5-e611-9795-005056862d7f



https://github.com/grumlimited/hmrc-test/blob/master/src/main/scala/uk/gov/hmrc/cli/Launcher.scala
https://github.com/kakumara/shopping-cart-hmrc/commit/d5749763deff43520136b75d95e3e2a7dce7e9f7
https://github.com/jinbal/HMRC-Shopping-Cart

java 8
sbt 0.13.x

try installing sbt from 

Tips
Name the test class as suite or spec.
In Scala, it is allowed to pass an argument to a method using the block
   * syntax, i.e. `{ argument }` instead of parentheses `(argument)`.
We recommend to always use the `===` equality operator when writing tests. This will give more details in the log for failing tests.
To test exceptions
  test("intNotZero throws an exception if its argument is 0") {
    intercept[IllegalArgumentException] {
      intNotZero(0)
    }
  }
use recursion as much as possible

For , Child < Parent

Child <: Parent  Covariant

Parent >: Child  Contravariant

For GrandChild < Child < Parent
S >: GrandChild <: Parent
S is all between Grandchild and Parent


Arrays are non covariant

Let us consider, C[T] with A and B such that A <: B
C[A] <: C[B]  C is Co variant
C[A] >: C[B]  C is Contra variant
C[A] is Non variant

The above is represented in Scala as follows
class C[+A] {...} //Co variance
class C[-A] {...} //Contra variance
class C[A] {...} //Non variant


Case class vs Class
Case classes can be seen as plain and immutable data-holding objects that should exclusively depend on their constructor arguments.
This functional concept allows us to
•use a compact initialisation syntax (Node(1, Leaf(2), None)))
•decompose them using pattern matching
•have equality comparisons implicitly defined 
In combination with inheritance, case classes are used to mimic algebraic datatypes.
If an object performs stateful computations on the inside or exhibits other kinds of complex behaviour, it should be an ordinary class.
•Case classes can be pattern matched
•Case classes automatically define hashcode and equals
•Case classes automatically define getter methods for the constructor arguments.


List vs Arrays
List is immutable
List is recursive , but Arrays are flat

